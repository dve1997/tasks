// Даны две строки word1 и word2.
// Вернуть минимальное количество операций, необходимых для преобразования word1 в word2.

function minDistance(word1, word2) {
  const m = word1.length;
  const n = word2.length;

  // Создаем двумерный массив dp размером (m+1) x (n+1)
  const dp = [];
  for (let i = 0; i <= m; i++) {
    dp[i] = new Array(n + 1);
  }

  // Инициализируем первую строку
  for (let j = 0; j <= n; j++) {
    dp[0][j] = j;
  }

  // Инициализируем первый столбец
  for (let i = 0; i <= m; i++) {
    dp[i][0] = i;
  }

  // Вычисляем минимальное количество операций для преобразования
  // каждой подстроки word1[0..i] в подстроку word2[0..j]
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (word1[i - 1] === word2[j - 1]) {
        // Если символы совпадают, то ничего не делаем и берем значение диагонального элемента
        dp[i][j] = dp[i - 1][j - 1];
      } else {
        // Иначе выбираем минимальное количество операций из трех возможных:
        // 1. Вставка - увеличиваем длину word1 на 1, оставляем длину word2 без изменений
        // 2. Удаление - увеличиваем длину word2 на 1, оставляем длину word1 без изменений
        // 3. Замена - увеличиваем длину word1 и word2 на 1
        dp[i][j] =
          Math.min(
            dp[i][j - 1], // вставка
            dp[i - 1][j], // удаление
            dp[i - 1][j - 1], // замена
          ) + 1;
      }
    }
  }

  return dp[m][n];
}

// console.log(minDistance('horse', 'ros'));
// console.log(minDistance('intention', 'execution'));
